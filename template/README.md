This is a template project. Based on it, you can write a cloud connector custom code, configure parameters, and perform both unit and integration testing. 

Consult sibling directories sample-xxx for examples of the Cloud Connector. These Cloud Connectors have been tested and work in production. For example, you can connect a device of type "moves" in the SAMI [User Portal](https://portal.samsungsami.io).

# Install

* Pre-required: [JDK 8](http://www.oracle.com/technetwork/java/javase/downloads/index.html) already installed. 
* Sync the repository that contains the Cloud Connector SDK and the template from [github](https://github.com/samsungsamiio/sami-cloudconnector-sdk).

Each command mentioned in this document should be launched from the current project directory, which contains build.gradle file. 

When running '../gradlew XXXX' commands in Section "Usages", `gradlew` will download the required tools and libraries on demand.

# Usages

### Code & compile Groovy code:
You can compile the template project without changing any code. However, the Cloud Connector built from it is useless since it does not do any real operation.

 * Edit [src/main/groovy/com/sample/MyCloudConnector.groovy](src/main/groovy/com/sample/MyCloudConnector.groovy)
    * Overwrite necessary methods to process subscription, notifications, and data fetching from the third party cloud
    * Use the following libraries in Groovy code :
     * [sami-cloudconnector-api 1.0.0](https://github.com/samsungsamiio/sami-cloudconnector-sdk/tree/master/apidoc)(TODO by David  <--confirm link, clicking it should load html page,right?)
     * [joda-time 2.3](http://www.joda.org/joda-time/apidocs/index.html) for date and time manipulation
     * [commons-codec 1.10](https://commons.apache.org/proper/commons-codec/archives/1.10/apidocs/index.html)
     * [scalactic 2.2.4](http://www.scalactic.org/), which provides a few helper constructs including classes [Or, Good, Bad](http://www.scalactic.org/user_guide/OrAndEvery)
 * Compile to check compilation errors
  ```
  ../gradlew classes
  ```

### Unit test

 * Edit [src/test/groovy/com/sample/MyCloudConnectorSpec.groovy](src/test/groovy/com/sample/MyCloudConnectorSpec.groovy)
 * Run unit test. Make sure to provide 'cleanTest' in the command to force run. Otherwise gradlew skip running test if the code was not changed since last time the command runs:
  ```
  ../gradlew cleanTest test
  ```

### Integration testing in the local environment:
You can perform manual integration testing on an HTTP (HTTPS) local server. The local server provides the minimal runtime environment to run the Cloud Connector. On this server, you can test authentication and fetching data from the third party cloud before uploading your Cloud Connector code to SAMI Developer Portal.

 * Edit [src/main/groovy/com/sample/cfg.json](src/main/groovy/com/sample/cfg.json) to setup the authentication from your local test server to the third party cloud. The information in cfg.json is pretty much the same as the information provided in [Cloud Authentication UI](https://developer-staging.samsungsami.io/sami/sami-documentation/using-cloud-connectors.html#set-authentication-parameters) at the SAMI Developer Portal. Here you will have to use cfg.json instead of the UI to do that. You can consult the following resources to learn how to write cfg.json
    * [cfg.json.sample](src/main/groovy/com/sample/cfg.json.sample) explains each JSON key.
    * sample-xxx/src/main/groovy/<package>/cfg.json is for each example cloud 
 * Test the CloudConnector on a local HTTP server.
    * To receive notification, your local server should be accessible via internet (for example, use a server accessible from the outside or use ssh tunnel with port forwarding)
    * You can customize the port of the local server (9080 by default for http and 9083 for https) by editing [utils.MyCloudConnectorRun](src/test/groovy/utils/MyCloudConnectorRun.groovy)
    * Temporarily update the configurations on the 3rd party cloud to use your local server for authentication and notification.
    * Run the test server (device type is hardcoded to 0000)
  ```
  ../gradlew runTestServer
  ```
    In the console, you should see the redirect and notification URIs as follows:
     ```
     redirect uri: http://localhost:9080/cloudconnectors/0000/auth
     notification uri: http://localhost:9080/cloudconnectors/0000/thirdpartynotifications
     ```
    * Start subscribing of a device by loading http://localhost:9080/cloudconnectors/0000/start_subscription in your browser.
    * Follow instructions displayed on the web page.
    * Generate new data in the 3rd party application, which triggers the notification from the 3rd party cloud to your local test server.
    * In the console, the test server should print a line with "0000: queuing event Event(" for each event generated by MyCloudConnector. One event is for one SAMI message.

*After finishing your integration testing, you should change the configuration on the 3rd party cloud to use SAMI instead of your local test server for authentication and notification.*

# Notes for MyCloudConnector.groovy

MyCloudConnector is a derived class that extends `com.samsung.sami.cloudconnector.api.CloudConnector`. Check out the following documentations to learn how to code it.

 * [High level view of the methods of CloudConnector class](https://developer-staging.samsungsami.io/sami/sami-documentation/using-cloud-connectors.html#define-the-cloud-connection)
 * [Moves Cloud Connector code explained](https://developer.samsungsami.io/sami/demos-tools/your-first-cloud-connector.html#implementation-details)
 * [CloudConnector API Doc](https://github.com/samsungsamiio/sami-cloudconnector-sdk/tree/master/apidoc)(TODO by David  <--confirm link, clicking it should load html page,right?), which lists functions and structures, and explains goals and usages.

### Best practices

 * CloudConnector should be stateless. So it should not have instance data, but you can use final constants.
 * All methods return [Or\<T, Failure\>](http://doc.scalatest.org/2.2.4/index.html#org.scalactic.Or) instead of a value of type T. `Or` is a `Good` or `Bad` instance depending on if the execution of the method succeeds or runs into an error. Create `Good` or `Bad` instance as following: 
    * `new Good(t)`, where t is an instance of `T`.
    * `new Bad(new Failure('this is an error message, put error details here'))`.

### Tips

* Use Context to retrieve configuration data such as clientId, clientSecret or your custom parameters:
```
{
  ...
    "parameters": {
      "myUrl": "http://www.foo.com/bar",
      "numberOfSomething": "10",
    },
  ...
}
```
  Those parameters will be sent to you groovy code in Context. You can access these parameter as the following example:
```
@Override
Or<List<RequestDef>, Failure> subscribe(Context ctx, DeviceInfo info) {
    ...
    ctx.parameters()["myUrl"]...
    ctx.parameters()["numberOfSomething"]...
    ...
}
```
* Perform unit and integration testing before submitting the Groovy Code in SAMI Developer Portal. This will increase the probability that the code is approved by SAMI and it works as you expected. 
* If you want to do type checking, uncomments the class annotation `//@CompileStatic`. Then, json manipulation will be more verbose.

### Unit Tests

Both samples and the template use [Spock framework](http://spockframework.github.io/spock/docs/1.0/index.html) for unit test. It is a groovy framework that reports in-equality more friendly than JUnit. However, you can use your favorite framework to do your own unit tests.

The class `utils.FakeContext` provides a default Context implementation, which that you can use and customize in your tests.

The class `utils.Tools` provides helper functions, for example, comparing list of events.

You can create text files under src/test/resources/<package> to store json and csv et al. The unit test calls utils.Tools.readFile() to read the content from these files.

There are more unit test examples in samples projects, for example, how to compare Json and Events and how to read text file et al.

### Integration Testing

If keeping the package 'com.sample', you run `../gradlew runTestServer` to start the server (see Usages section). Otherwise, you have to replace `com.sample` by the right package name in the `task runTestServer` of the file `build.gradle`.
```
task runTestServer(type:JavaExec) {
  main = System.getProperty("exec.mainClass") ?: "utils.MyCloudConnectorRun"
  args = ["com.sample"]
  classpath = sourceSets.test.runtimeClasspath
}
```

It is possible to customize ports, hostname, certificate by editing the file [src/test/groovy/utils/MyCloudConnectorRun.groovy](src/test/groovy/utils/MyCloudConnectorRun.groovy).

You can configure logging in [src/test/resources/logback-test.xml](src/test/resources/logback-test.xml).

#### Enable HTTS/SSL

If third party cloud require https for authentication and notification, then you have to customize `utils/MyCloudConnectorRun.groovy`.

1. Select a domain/host name that you can used (eg. my.domain.com). **Don't forget to register it into your /etc/hosts or your DNS'registar**
1. Enable https port by setting a no-null value for httpsPort parameter (eg. 9083). If you try to connect to https://my.domain.com:9083/ a self-signed certificate will be generated and used.

  ```
  def srvCfg = SimpleHttpServer.makeServerConfig('my.domain.com', 9080, 9083, null, null, null, null)
  ```
1. If third party cloud doen't accept self-signed certificate (it's often the case, because it's a security failure), then you have to acquire a SSL certificate from an authority, or since end of 2015 you can acquire it with [Let's Encrypt](https://letsencrypt.org/howitworks/) (free)

  ```
  # install letsencrypt
  # generate a certificate from the server (my.domain.com)
  DOMAIN=my.domain.com
  sudo ./letsencrypt-auto -d $DOMAIN certonly --standalone
  sudo tar -czvf ../$DOMAIN.tar.gz /etc/letsencrypt/archive/$DOMAIN
  ```
1. Store the certificate in a keystore (usable by TestServer)

  ```
  cd sami-cloudconnector-sdk/<my_cloudconnector>
  tar -xzvf $DOMAIN.tar.gz
  cd etc/letsencrypt/archive/$DOMAIN
  # convert certificate chain + private key to the PKCS#12 file format, select a password of at least 6 characters
  openssl pkcs12 -export -out keystore.pkcs12 -in fullchain1.pem -inkey privkey1.pem
  # convert PKCS#12 file into Java keystore format, use the same password than previously for keystore (source and destination), else you'll have Exception like "java.security.UnrecoverableKeyException: Cannot recover key"
  keytool -importkeystore -srckeystore keystore.pkcs12 -srcstoretype pkcs12 -destkeystore keystore.jks
  # don't need the PKCS#12 file anymore
  rm keystore.pkcs12
  ```
1. Edit MyCloudConnectorRun.groovy to use the keystore with the certificate (don't forget to change the domain name, the path, the password)

  ```
  def srvCfg = SimpleHttpServer.makeServerConfig('my.domain.com', 9080, 9083, "etc/letsencrypt/archive/my.domain.com/keystore.jks", null, "keyStorePassword", null)
  ```
1. Try it https://my.domain.com:9083/
